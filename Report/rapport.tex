\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{hyperref}
\usepackage{xcolor}

\hypersetup{
    colorlinks=true,
    linkbordercolor = {white},
    linkcolor=black,
    urlcolor=cyan
}
\title{\Huge Problème de clique maximum}

\author{\texttt{reda-mohamed.drissi@isty.uvsq.fr}\\
        Drissi Mohamed Reda}
\date{19 Fevrier 2018}
\begin{document}
\makeatletter
    \begin{titlepage}
        \begin{center}
        	\includegraphics[width=40mm]{Report/uvsq-header.png}\par \vspace{1cm}
            {\@title }\\[4ex]
            {\@author}\\[4ex]
            {\@date} \\ [4ex]
        \end{center}
    \end{titlepage}
\makeatother
\thispagestyle{empty}
\newpage
\tableofcontents
\newpage
\section{Introduction}
Nous prenons un graphe $G=\{V,E\}$ tel que $V$ est l'ensemble des sommets
et $E$ l'ensemble des arrêtes(Nous ignorons les arrêtes liant une arrête à elle même). \\
Nous nommons les sommets du graphe 1,2, ... n. Cet algorithme permet de trouver une clique
de taille d'au moins $k$. À chaque étape, si nous trouvons une clique de taille d'au moins
$k$, nous arrêtons.\\
Nous devons essayer chaque valeur $k$ possible, pour cela nous allons essayer de calculer la valeur
$k$ minimale (\textbf{lower bound}) avec la formule \\
$\forall \omega \subset $\{ensemble de toutes les cliques\} $|\omega| \geq \frac{1}{1-\delta}$
tel que la densité est $\delta=\frac{2m}{n^2}$
\section{Algorithme}
\subsection{Algorithme}
\begin{algorithm}
\begin{algorithmic}
  \Function{Expand\_clique}{Graph Q}
  \While{$\exists$ v joignable à Q}
    \State trouver $v_{max}$ tel que Le nombre de sommets joignable à la clique $Q \cup \{v_{max}\}$ est maximal
    \State $Q \gets Q\cup \{v_{max}\}$
  \EndWhile
    \State \Return $Q$
  \EndFunction
\end{algorithmic}
\end{algorithm}
\begin{algorithm}
\begin{algorithmic}
  \Function{Alter\_Clique}{Graph Q}
  \State Trouver $v \notin Q$ tel que $\exists! w \in Q$ non adjacent à $v$.
    \If{$v = \varnothing$}
      \State \Return $Q$
    \Else
      \State $Q\gets Q \setminus \{w\}$
      \State $Q \gets Q \cup \{v\}$
      \State $Q \gets$ \Call{Expand\_clique}{Q}
      \State \Return $Q$
    \EndIf
  \EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[!htp]
\caption{Algorithme de clique de taille k}
\begin{algorithmic}[1]
  \For{i $\in$ [1,n]}
    \State initialiser la clique $Q_i\gets \{i\}$
    \State $Q_i \gets$ \Call{Expand\_Clique}{$Q_i$}
    \For{i $\in$ [1,k]}
      \State $Q_i \gets$ \Call{Alter\_Clique}{$Q_i$}
    \EndFor
  \EndFor
  \ForAll{$Q_i$ et $Q_j$ trouvés}
    \State initialiser la clique $Q_{i,j} \gets Q_i \cap Q_j$
    \State $Q_{i,j} \gets$ \Call{Expand\_Clique}{$Q_{i,j}$}
    \For{i $\in$ [1,k]}
      \State $Q_i \gets$ \Call{Alter\_Clique}{$Q_i$}
    \EndFor
  \EndFor

\end{algorithmic}
\end{algorithm}
\subsection{Example}
Comme exemple nous prenons le graphe complémentaire du \href{https://en.wikipedia.org/wiki/Frucht\_graph}{graphe de Frucht}
Avec les sommets :
\begin{displaymath}
  V=\{1,2,3,...12\}
\end{displaymath}
\begin{center}
  \begin{figure}[!htp]
    \caption{Complément du graphe de Frucht}
    \includegraphics[scale=0.5]{Report/frucht-compl.png}
  \end{figure}
\end{center}

Nous allons faire tourner cet algorithme pour trouver une clique d'au moins $k=5$. \\
Pour i=1 et i=2 nous trouvons des cliques de taille 4 donc nous passons à i=3.
Initialisation : $Q_3=\{i\}=\{3\}$. \\
Nous exécutons la fonction \textit{Expand\_Clique}
\begin{center}
  \begin{tabular}{|c|c|c|}
    \hline
    sommet $v$ joignable à $Q_3$ & sommets joignables à $Q_3\cup\{v\}$ & taille \\ \hline
    \hline
    1 	& 5, 6, 8, 9, 12  	& 5 \\ \hline
    5   & 1, 7, 8, 11, 12   & 5 \\ \hline
    6 	& 1, 9, 11, 12  	  & 4 \\ \hline
    7 	& 5, 9, 11, 12  	  & 4 \\ \hline
    8 	& 1, 5, 9, 11 	    & 4 \\ \hline
    9 	& 1, 6, 7, 8, 11 	  & 5 \\ \hline
    11 	& 5, 6, 7, 8, 9, 12 & 6 \\ \hline
    12 	& 1, 5, 6, 7, 11  	& 5 \\ \hline
  \end{tabular}
\end{center}
Nous trouvons que le maximum est :
\begin{displaymath}
  |Q_3 \cup \{v\}|_{max}=6 \quad pour \quad v=11
\end{displaymath}
Nous ajoutons le sommet $6$ à $Q$. Nous retrouvons la nouvelle clique \\
$Q_3=\{3, 11\}$ de taille 2.
\begin{center}
  \begin{tabular}{|c|c|c|}
    \hline
    sommet $v$ joignable à $Q_3$ & sommets joignables à $Q_3\cup\{v\}$ & taille \\ \hline
    \hline
    5 	& 7, 8, 12 	& 3 \\ \hline
    6 	& 9, 12 	  & 2 \\ \hline
    7 	& 5, 9, 12 	& 3 \\ \hline
    8 	& 5, 9 	    & 2 \\ \hline
    9 	& 6, 7, 8 	& 3 \\ \hline
    12 	& 5, 6, 7 	& 3 \\ \hline
  \end{tabular}
\end{center}
Nous trouvons que le maximum est :
\begin{displaymath}
  |Q_3 \cup \{v\}|_{max}=3 \quad pour \quad v=5
\end{displaymath}
Nous ajoutons le sommet $5$ à $Q$. Nous retrouvons la nouvelle clique \\
$Q_3=\{3, 5, 11\}$ de taille 3.
\begin{center}
  \begin{tabular}{|c|c|c|}
    \hline
    sommet $v$ joignable à $Q_3$ & sommets joignables à $Q_3\cup\{v\}$ & taille \\ \hline
    \hline
    7 	& 12 	            & 1 \\ \hline
    8 	& $ \varnothing$ 	& 0 \\ \hline
    12 	& 7 	            & 1 \\ \hline
  \end{tabular}
\end{center}
Nous trouvons que le maximum est :
\begin{displaymath}
  |Q_3 \cup \{v\}|_{max}=1 \quad pour \quad v=7
\end{displaymath}
Nous ajoutons le sommet $12$ à $Q$. Nous retrouvons la nouvelle clique \\
$Q_3=\{3, 5, 7, 11\}$ de taille 4.
\begin{center}
  \begin{tabular}{|c|c|c|}
    \hline
    sommet $v$ joignable à $Q_3$ & sommets joignables à $Q_3\cup\{v\}$ & taille \\ \hline
    \hline
    12    & $\varnothing$ & 0 \\ \hline
  \end{tabular}
\end{center}
Nous trouvons que le maximum est :
\begin{displaymath}
  |Q_3 \cup \{v\}|_{max}=0 \quad pour \quad v=12
\end{displaymath}
Nous ajoutons le sommet $12$ à $Q$. Nous retrouvons la nouvelle clique \\
$Q_3=\{3, 5, 7, 11, 12\}$ de taille 5.\\
Puisque la clique est de taille 5, nous nous arrêtons là.
\section{Complexité}
Nous allons calculer la complexité de cet algorithme :
Nous allons supposer les cas les plus pessimistes, bien que ça ne soit impossible pour en arriver
à ce genre de situations, la plupart des cas testés trouvent un résultat dans la fonction
\textit{find\_cliques} sans passer à \textit{pairwise\_intersections}.\\
Soit $G$ un graphe ayant $n$ sommets et une clique $Q$ :
\subsection{complexité de \textit{add\_vertex}}
La fonction \textit{adjoinable} prend au pire $n^2$ itérations donc une complexité de $O(n^2)$.
Car chaque sommet moins de $n$ sommets qui ne sont pas voisins, et cela prends $n$ itérations pour
vérifier si un sommet non voisin ne fait pas partie de la clique.\\
Pour chaque clique, trouver le nombre de sommets joignables prends au pire $n$ fois la fonction
\textit{adjoinable}, ce qui en résulte que la complexité de la fonction \textit{max\_adjoinable} est
de $O(n^3)$.\\
Puis pour chaque clique trouver qu'un sommet où le nombre de sommets joignables est maximal prends
$n$ fois la fonction \textit{max\_adjoinable}, puisqu'il y a au pire, $n$ sommets en dehors de la
clique, donc $n*O(n^3)=O(n^4)$. La fonction \textit{add\_vertex} s'achève si au pire $n$ sommets
ont été ajoutés à la clique donc nous trouvons $n*O(n^4)=O(n^5)$.\\
La complexité de \textit{add\_vertex} est de $O(n^5)$.
\subsection{Complexité de \textit{expand\_vertex}}
Pour trouver un sommet $v \notin Q$ qui a exactement un sommet $w \in Q$ qui n'est pas son voisin
nous avons besoin d'au pire $n^2$ itérations. Si nous trouvons un tel sommet $w$ nous avons besoin
d'une seule itération.\\ Puis nous avons besoin de $O(n^5)$ pour performer \textit{add\_vertex}.\\
La complexité de \textit{expand\_vertex} est donc de $O(n^5)$.
\subsection{Complexité de \textit{find\_cliques}}
Pour chaque itération, \textit{add\_vertex} prends $O(n^5)$ puis \textit{expand\_vertex} est exécutée
au pire $n$ fois (puisque $k \leq n$). Alors la complexité est de $O(n^5+n*n^5)=O(n^6)$. \\
Puisqu'on exécute ces itérations $n$ fois, alors la complexité devient :
\begin{displaymath}
  O(n*n^6)=O(n^7)
\end{displaymath}
\subsection{Complexité de \textit{pairwise\_intersections}}
Nous avons moins de $n^2$ de paires distinctes de cliques maximales trouvées par \textit{find\_cliques}
Donc similairement à \textit{find\_cliques} pour chaque itération la complexité sera de $O(n^5+n*n^5)=O(n^6)$
exécutée $n^2$ fois, cela donne $n^2*O(n^6)=O(n^8)$.
\subsection{Complexité totale}
La complexité totale sera la somme de la complexité de \textit{find\_cliques}, \textit{find\_neighbors}
et \textit{pairwise\_intersections}. Donc :
\begin{displaymath}
C(n)=O(n^2)+O(n^7)+O(n^8)
\end{displaymath}

\section{Implémentation en C++}
Nous implémentons en C++ l'algorithme trouvé précédemment pour trouver la clique
maximum d'un graphe.\\
Nous mettons en place plusieurs mode :
\begin{itemize}
  \item \textbf{Verbose :} Dans ce mode, plus d'informations sont écrites sur la sortie standard.
  \item \textbf{Fast :} Dans ce mode nous évitons de vérifier les intersections 2 à 2 de $Q_i$ et $Q_j$
  \item \textbf{taille de clique donnée} L'information de la taille de la clique souhaitée peut être fournie, dans
    ce cas, nous pouvons gagner beaucoup en temps d'exécution.
\end{itemize}
\section{Test de gestion de mémoire Valgrind ©}
Nous allons utiliser valgrind pour un cas où l'algorithme parcours toutes ses fonctions, donc
pour tester un cas où $k > |Q_{max}|$.\\
Il faut bien sûr faire tourner le programme en mode non verbose pour ne garder que le principal.
\begin{verbatim}
  ==32052== Memcheck, a memory error detector
  ==32052== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
  ==32052== Using Valgrind-3.12.0.SVN and LibVEX; rerun with -h for copyright info
  ==32052== Command: ./clique MANN_a9 17
  ==32052==
  Graph MANN_a9
  Graph has n = 45 vertices.
  Find a Clique of size at least k = 17
  Finding Cliques...
  Could not find Clique of size at least 17.
  Maximum Clique size found 16.
  Results are stored in outclq/MANN_a9.out file
  ==32052==
  ==32052== HEAP SUMMARY:
  ==32052==     in use at exit: 0 bytes in 0 blocks
  ==32052==   total heap usage: 36,143,744 allocs, 36,143,744 frees, 2,651,510,276 bytes allocated
  ==32052==
  ==32052== All heap blocks were freed -- no leaks are possible
  ==32052==
  ==32052== For counts of detected and suppressed errors, rerun with: -v
  ==32052== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\end{verbatim}
Pour plus de détails, voir le fichier \texttt{valgrind-out}.\\
Nous remarquons qu'ils n'y a pas d'erreurs de mémoires, ni de fuites possibles.
\section{Test}
Nous allons faire tourner notre code C++ sur plusieurs graphes, notre algorithme
nous permet de choisir la taille de la clique souhaitée, cela rends le code plus pratique
pour s'assurer de trouver la clique maximale, nous allons choisir un nombre n=k
Ce graphe :
\begin{center}
  \begin{verbatim}
    0 0 0 1 0 0 1
    0 0 0 0 1 0 1
    0 0 0 0 0 1 1
    1 0 0 0 1 1 0
    0 1 0 1 0 1 0
    0 0 1 1 1 0 0
    1 1 1 0 0 0 0
  \end{verbatim}
\end{center}
donne le résultat :
\begin{center}
  \begin{verbatim}
  1. Clique of size 3 : 4 5 6
  \end{verbatim}
\end{center}
Passons aux choses sérieuses, nous avons téléchargé des graphes en format \texttt{.clq.b} depuis les
instances de \href{https://cse.unl.edu/~tnguyen/npbenchmarks/clique.html}{DIMAC}. \\
Avant de passer aux tests il faut expliquer l'arborescence des fichiers.
\begin{itemize}
  \item \textbf{bingraph:} Contient les graphes téléchargés depuis le site en \texttt{.clq}.
  \item \textbf{edgls:} Contient les listes d'arrêtes de chaque graphe en \texttt{.ls} convertie avec \texttt{bin2asc}
    obtenu depuis \href{https://cse.unl.edu/~tnguyen/npbenchmarks/instances/converter.tar.gz}{ce site}.
  \item \textbf{adjmat:} Contient les matrices d'adjacences en \texttt{.mat}obtenues avec \texttt{edgtoadj}
  \item \textbf{outclq:} Contient les cliques résultantes en \texttt{.out}.
\end{itemize}
Nous pouvons obtenir le graphe sous différentes formes depuis les dossiers précédemment mentionnés.\\
\textbf{N.B:} Nous allons compiler en mode non verbose (par défaut) pour ne retenir que les informations
importantes, le détail sera à consulter depuis les \texttt{.out}.
\paragraph{Brock200\_1}
Commande :
\begin{verbatim}
  time ./clique adjmat/brock200_1.mat 21
\end{verbatim}
Résultat
\begin{verbatim}
  Graph adjmat/brock200_1.mat
  density is 0.74175
  Graph has n = 200 vertices, fast mode
  Finding Cliques...
  Find a Clique of size at least k = 21
  Found Clique of size at least 21
  Results are stored in outclq/brock200_1.out file
\end{verbatim}
Temps d'exécution
\begin{verbatim}
  real	0m1.776s
  user	0m1.772s
  sys	0m0.000s
\end{verbatim}
Sans entrer K nous trouvons :\\
Résultat
\begin{verbatim}
  Graph adjmat/brock200_1.mat
  density is 0.74175
  Graph has n = 200 vertices, fast mode
  Finding Cliques...
  Find a Clique of size at least k = 4
  Find a Clique of size at least k = 18
  Find a Clique of size at least k = 21
  Find a Clique of size at least k = 22
  Could not find Clique of size at least 22
  Maximum Clique size found 21
  Results are stored in outclq/brock200_1.out file
\end{verbatim}
Temps d'exécution
\begin{verbatim}
  real	0m17.942s
  user	0m17.940s
  sys	0m0.000s
\end{verbatim}
\paragraph{Keller4}
Commande :
\begin{verbatim}
  time ./clique adjmat/keller4.mat 11
\end{verbatim}
Résultat
\begin{verbatim}
  Graph keller4
  Graph has n = 171 vertices.
  Find a Clique of size at least k = 11
  Finding Cliques...
  Found Clique of size at least 11.
  Results are stored in outclq/keller4.out file
\end{verbatim}
Temps d'exécution :
\begin{verbatim}
  real	0m0.036s
  user	0m0.032s
  sys	  0m0.000s
\end{verbatim}
Sans entrer K nous trouvons :\\
Résultat
\begin{verbatim}
  Graph adjmat/keller4.mat
  density is 0.645327
  Graph has n = 171 vertices, fast mode
  Finding Cliques...
  Find a Clique of size at least k = 3
  Find a Clique of size at least k = 12
  Could not find Clique of size at least 12
  Maximum Clique size found 11
  Results are stored in outclq/keller4.out file
\end{verbatim}
Temps d'exécution
\begin{verbatim}
  real	0m6.036s
  user	0m6.032s
  sys	  0m0.000s
\end{verbatim}
\paragraph{MANN\_a9}
Commande :
\begin{verbatim}
  time ./clique adjmat/MANN_a9.mat 16
\end{verbatim}
Résultat
\begin{verbatim}
  Graph MANN_a9
  Graph has n = 45 vertices.
  Find a Clique of size at least k = 16
  Finding Cliques...
  Found Clique of size at least 16.
  Results are stored in outclq/MANN_a9.out file
\end{verbatim}
Temps d'exécution
\begin{verbatim}
  real	0m0.005s
  user	0m0.004s
  sys	  0m0.000s
\end{verbatim}
Sans entrer K nous trouvons :\\
Résultat
\begin{verbatim}
  Graph adjmat/MANN_a9.mat
  density is 0.907654
  Graph has n = 45 vertices, fast mode
  Finding Cliques...
  Find a Clique of size at least k = 11
  Find a Clique of size at least k = 17
  Could not find Clique of size at least 17
  Maximum Clique size found 16
  Results are stored in outclq/MANN_a9.out file
\end{verbatim}
Temps d'exécution
\begin{verbatim}
  real	0m0.334s
  user	0m0.320s
  sys	  0m0.000s
\end{verbatim}
\paragraph{Sanr200\_0.7}
Commande :
\begin{verbatim}
  time ./clique adjmat/sanr200_0.7.mat 18
\end{verbatim}
Résultat
\begin{verbatim}
  Graph sanr200_0.7
  Graph has n = 200 vertices.
  Find a Clique of size at least k = 18
  Finding Cliques...
  Found Clique of size at least 18.
  Results are stored in outclq/sanr200_0.7.out file
\end{verbatim}
Temps d'exécution
\begin{verbatim}
    real	0m0.277s
    user	0m0.276s
    sys	  0m0.000s
\end{verbatim}
Sans entrer K nous trouvons :\\
Résultat
\begin{verbatim}
  Graph adjmat/sanr200_0.7.mat
  density is 0.69345
  Graph has n = 200 vertices, fast mode
  Finding Cliques...
  Find a Clique of size at least k = 4
  Find a Clique of size at least k = 17
  Find a Clique of size at least k = 18
  Find a Clique of size at least k = 19
  Could not find Clique of size at least 19
  Maximum Clique size found 18
  Results are stored in outclq/sanr200_0.7.out file
\end{verbatim}
Temps d'exécution
\begin{verbatim}
  real	0m13.637s
  user	0m13.628s
  sys	  0m0.004s
\end{verbatim}

\end{document}
